#pragma once

#include <array>
#include <string>
#include <ncurses.h>
#include <unistd.h>
#include <cstdlib>

#include "IKeyboardInputObserver.hpp"

class Window : public IKeyboardInputObserver
{
public:
    Window() {
        if ( (_windowHandle = initscr()) == nullptr ) {
            fprintf(stderr, "Error initialising ncurses.\n");
            exit(EXIT_FAILURE);
        }

        noecho();
        keypad(_windowHandle, TRUE);
        start_color();
        curs_set(0);
    }

    ~Window() {
        delwin(_windowHandle);
        endwin();
        refresh();
    }

    void onKeyPressed(int ch) override {
        switch ( ch ) {

        case KEY_UP:
            if ( y > 0 )
            --y;
            break;

        case KEY_DOWN:
            if ( y < rows - 1 )
            ++y;
            break;

        case KEY_LEFT:
            if ( x > 0 )
            --x;
            break;

        case KEY_RIGHT:
            if ( x < cols - 1)
            ++x;
            break;
        }
    
        clear();
        drawMap(stringToMap(MAP));
        mvprintw(y, x, "@");
        refresh();
    }

private:
    enum class Tile {
        Dirt, Wall
    };

    void drawMap(const std::array<std::array<Tile, 80>, 25>& map) {
        for(std::size_t posY = 0; posY < 25; ++posY) {
            std::string mapRow {};
            for(std::size_t posX = 0; posX < 80; ++posX) {
                if (map[posY][posX] == Tile::Dirt)
                    mapRow += '.';
                if (map[posY][posX] == Tile::Wall)
                    mapRow += '#';
            }
            mvprintw(posY, 0, mapRow.c_str());
        }
    }

    WINDOW * _windowHandle;
    const int rows  = 25;
    const int cols   = 80;
    int x = 0;
    int y = 0;
    
    const std::array<std::string, 25> MAP {
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................######..........................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................",
        "................................................................................"
    };

    std::array<std::array<Tile, 80>, 25> stringToMap(const std::array<std::string, 25>& rawMap) {
        std::array<std::array<Tile, 80>, 25> map {};
        for(std::size_t posY = 0; posY < 25; ++posY) {
            for(std::size_t posX = 0; posX < 80; ++posX) {
                if (rawMap[posY][posX] == '.')
                    map[posY][posX] = Tile::Dirt;
                if (rawMap[posY][posX] == '#')
                    map[posY][posX] = Tile::Wall;
            }
        }

        return map;
    }
};